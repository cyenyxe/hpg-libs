#include "vcf_reader.h"

int lines = 0;
int batches = 0;
// int count = 0;

%%{
	machine vcf;
	write data;
	
	#################################################
	# 		Actions definition		#
	#################################################

    action linebreak {
        lines++;
    }
    
    action header_id_begin {
        ts = p;
    }

    action header_id_end {
        set_header_entry_name(ts, p-2-ts, status->current_header_entry);
    }

    action header_field_id_begin {
        ts = p;
    }

    action header_field_id_end {
        if (status->current_header_entry->name != NULL)
        {
            add_header_entry_key(ts, p-ts, status->current_header_entry);
        } else {
            // Entries like ##reference=some_text_here
            status->current_header_entry = create_header_entry();
            set_header_entry_name(ts, p-ts, status->current_header_entry);
        }
    }

    action header_field_value_begin {
        ts = p;
    }

    action header_field_value_end {
        // Remove quotation marks if necessary
        char *start = ts, *end = p;
        if (*ts == '"') start = ts + 1;
        if (*(p-1) == '"') end = p - 1;
        
        add_header_entry_value(start, end-start, status->current_header_entry);
    }

    action sample_name_begin {
        ts = p;
    }

    action sample_name_end {
        add_sample_name(ts, p-ts, file);
    }

    action record_begin {
        status->current_record = create_record();
    }
	
    action record_end {
        // If batch is full, add to the list of batches and create a new, empty one
//         if (vcf_batch_is_full(status->current_batch))
        if (batch_size > 0 && status->current_batch->records->size == batch_size)
        {
            list_item_t *item = list_item_new(file->num_records, 1, status->current_batch); 
            list_insert_item(item, batches_list);
//             printf("Batch %d added - %zu records\t", batches, status->current_batch->records->size);
            status->current_batch = vcf_batch_new(batch_size);           
            if (p+1) {
                status->current_batch->text = p+1;
//                 printf("batch text = '%.*s'\n", 50, status->current_batch->text);
            }
            batches++;
        }

        // If not a blank line, add status->current record to status->current batch
//         if (status->current_field != CHROM) {
            add_record_to_vcf_batch(status->current_record, status->current_batch);
            status->num_records++;
//             printf("Record %zu added\n", status->num_records);
//         }
        
//         status->current_field = CHROM;
        status->num_samples = 0;
//         LOG_DEBUG("\n");
    }
	
    action chrom_begin {
        ts = p;
//         printf("chromosome begin %c%c\n", ts[0], ts[3]);
    }

    action chrom_end {
//         printf("chromosome end %c...%c\n", *ts, *p);
        set_record_chromosome(ts, p-ts, status->current_record);
    }

action chrom_error {
        printf("Line %d: Error in 'chromosome' field\n", lines);
    }

    action pos_begin {
        ts = p;
//         printf("position\n");
    }

    action pos_end {
        char *field = strndup(ts, p-ts);
        set_record_position(atol(field), status->current_record);
//         printf("Position = %ld\n", atol(field));
        free(field);
    }

    action pos_error {
        printf("Line %d: Error in 'position' field\n", lines);
    }

    action id_begin {
        ts = p;
//         printf("id\n");
    }

    action id_end {
        set_record_id(ts, p-ts, status->current_record);
    }

    action id_error {
        printf("Line %d: Error in 'id' field\n", lines);
    }

    action ref_begin {
        ts = p;
//         printf("reference\n");
    }

    action ref_end {
        set_record_reference(ts, p-ts, status->current_record);
    }

    action ref_error {
        printf("Line %d: Error in 'reference' field\n", lines);
    }

    action alt_begin {
        ts = p;
//         printf("alternate\n");
    }

    action alt_end {
        if (!strncmp("0", ts, 1) || !strncmp("<DEL>", ts, 5)) {
            set_record_alternate(".", 1, status->current_record);
        } else {
            set_record_alternate(ts, p-ts, status->current_record);
        }
    }

    action alt_error {
        printf("Line %d: Error in 'alternate' field\n", lines);
    }

    action qual_begin {
        ts = p;
//         printf("quality\n");
    }

    action qual_end {
        float quality = -1.0f;
        if (strncmp(".", ts, 1) != 0) {
            char *field = strndup(ts, p-ts);
            quality = atof(field);
            free(field);
        }
        set_record_quality(quality, status->current_record);
    }

    action qual_error {
        printf("Line %d: Error in 'quality' field\n", lines);
    }

    action filter_begin {
        ts = p;
//         printf("filter\n");
    }

    action filter_end {
        set_record_filter(ts, p-ts, status->current_record);
    }

    action filter_error {
        printf("Line %d: Error in 'filter' field\n", lines);
    }

    action info_begin {
        ts = p;
//         printf("info\n");
    }

    action info_end {
        set_record_info(ts, p-ts, status->current_record);
    }

    action info_error {
        printf("Line %d: Error in 'info' field\n", lines);
    }

    action format_begin {
        ts = p;
//         printf("format\n");
    }

    action format_end {
        set_record_format(ts, p-ts, status->current_record);
    }

    action format_error {
        printf("Line %d: Error in 'format' field\n", lines);
    }

    action sample_begin {
        ts = p;
//         printf("sample\n");
    }

    action sample_end {
        add_record_sample(ts, p-ts, status->current_record);
    }

    action sample_error {
        printf("Line %d: Error in sample\n", lines);
    }

	#################################################
	# 		Machine definition		#
	#################################################
	
	number		= (digit)+ ("." (digit)+)? ;					# Integer or floating-point number
	bases		= ("A" | "C" | "G" | "T" | "N")+ ;
	identifier	= (alnum)+ ;
	
	# File format
	format_name	= (alnum | punct)+ ;
	fileformat	= "##fileformat=" format_name "\n" >linebreak;
	
	# Header
	field_name	= identifier ;
	field_value	= (print)+ ;
	header_field	= (field_name "=")? field_value ;
	entry_name	= (alnum | "_")+ ;
	header_entry	= "##" identifier "=<" (header_field)+ ">\n" | "##" identifier "=" field_value "\n" | "##" field_value "\n" >linebreak ;
	header		= (header_entry)+ ;
	
	# Delimiter between header and records
	sample_name	= (print - ("\n" | "\t"))+ ;
	delimiter	= "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT" ("\t" sample_name >sample_name_begin %sample_name_end)+ "\n" >linebreak;

	# Records
	record_chrom	= (alnum | "_")+ ;
	record_pos	= (digit)+ ;
	record_id	= (alnum)+ | "." ;					# Alphanumeric string or one dot
	record_ref	= bases ;
	record_alt	= (bases ("," bases)*)+ | "." | "<DEL>" | "0" ;				# Comma-separated bases or one dot
	record_qual	= number | "." ;					# Number or dot
	
	filter_value	= (alnum | "_")+ ;
	filter_entry	= filter_value ("," filter_value)* ;
	record_filter	= "." | filter_entry (";" filter_entry)* ;
	
	
	info_id		= (alnum | "_")+ | "." ;
	info_value	= (print - space)+ ;
	info_value_list	= info_value ("," info_value)* ;
	info_entry	= info_id | info_id "=" info_value_list ;
	record_info	= info_entry (";" info_entry)* ;
	
	record_format	= (alnum)+ (":" (alnum)+)* ;
	record_sample	= (alnum | punct)+ (":" (alnum | punct)+)* ;
	record		= (record_chrom >chrom_begin %chrom_end $err(chrom_error) "\t" 
                   record_pos >pos_begin %pos_end $err(pos_error) "\t" 
                   record_id >id_begin %id_end $err(id_error) "\t" 
                   record_ref >ref_begin %ref_end $err(ref_error) "\t" 
                   record_alt >alt_begin %alt_end $err(alt_error) "\t" 
                   record_qual >qual_begin %qual_end $err(qual_error) "\t" 
                   record_filter >filter_begin %filter_end $err(filter_error) "\t" 
                   record_info >info_begin %info_end $err(info_error) "\t" 
                   record_format >format_begin %format_end $err(format_error) 
                   ("\t" record_sample >sample_begin %sample_end $err(sample_error))+) 
                   >record_begin %record_end ;
	records		=  record ("\n" >linebreak record)* ("\n")? ;
	
	# Machine start
#	main		:= fileformat >entering_format $inside_format @leaving_format %begin_header header >end_header delimiter %records_begin records %records_end ;
    main        := (fileformat)? ("\n")* (header)? ("\n")* (delimiter)? ("\n")* (records)? ("\n")* ;

	
	#################################################
	# 		Scanner definition		#
	#################################################
	
}%%


int execute_vcf_ragel_machine(char *p, char *pe, list_t *batches_list, size_t batch_size, vcf_file_t *file, vcf_reader_status *status) {
    int cs;
    char *ts, *te;
    int stack[4];
    int top, act;
    char *eof = pe;

    status->current_batch->text = p;
//     printf("ragel - batch text = '%.*s'\n", 50, status->current_batch->text);

    %%{
        write init;
        write exec;
    }%%
    
    if (!vcf_batch_is_empty(status->current_batch)) {
        list_item_t *item = list_item_new(file->num_records, 1, status->current_batch);
        list_insert_item(item, batches_list);
//         printf("Batch added - %zu records (self-contained)\n", status->current_batch->records->size);
    }

//     printf("ragel - first chromosome = %.*s\n", 
//            ((vcf_record_t*) status->current_batch->records->items[0])->chromosome_len, 
//            ((vcf_record_t*) status->current_batch->records->items[0])->chromosome);
// 
//     printf("final state should be a minimum of %d, was %d\n",  %%{ write first_final; }%%, cs);
    return cs < %%{ write first_final; }%%;
}

vcf_reader_status *vcf_reader_status_new(size_t batch_lines, int store_samples, int self_contained) {
    vcf_reader_status *status = (vcf_reader_status *) malloc (sizeof(vcf_reader_status));
    status->current_record = NULL;
    status->current_header_entry = create_header_entry();
    if (batch_lines == 0) {
        status->current_batch = vcf_batch_new(500);
    } else if (batch_lines > 0) {
        status->current_batch = vcf_batch_new(batch_lines);
    }

    status->num_samples = 0;
    status->num_records = 0;

    status->store_samples = store_samples;
    status->self_contained = self_contained;

    return status;
}

void vcf_reader_status_free(vcf_reader_status *status) {
    if (status->current_header_entry->name == NULL && status->current_header_entry->num_keys == 0 && status->current_header_entry->num_values == 0) {
        vcf_header_entry_free(status->current_header_entry);
    }
    if (vcf_batch_is_empty(status->current_batch)) {
        vcf_batch_free(status->current_batch);
    }
    if (status->current_record->chromosome == NULL && status->current_record->samples->size == 0) {
        vcf_record_free(status->current_record);
    }
    free(status);
}


/* **********************************************
 *              Reading and parsing             *
 * **********************************************/

int vcf_read_and_parse(list_t *batches_list, size_t batch_size, vcf_file_t *file, int read_samples) {
    int cs = 0;
    char *p, *pe;

    vcf_reader_status *status = vcf_reader_status_new(batch_size, read_samples, 0);
    
    if (mmap_vcf) {
        LOG_DEBUG("Using mmap for file loading\n");
        p = file->data;
        pe = p + file->data_len;
        cs = execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
    } else {
        LOG_DEBUG("Using file-IO functions for file loading\n");
        size_t max_len = 256;
        int eof_found = 0;
        char *aux;

        // Read text of a batch and call ragel parser in a loop
        while (!eof_found) {
            char *data = (char*) calloc (max_len, sizeof(char));
            int c = 0;
            int lines = 0;

            for (int i = 0; !eof_found && lines < batch_size; i++) {
                c = fgetc(file->fd);
                
                if (c != EOF) {
                    max_len = consume_input(c, &data, max_len, i);
                    if (c == '\n') {
                        lines++;
                    }
                    (file->data_len)++;
                } else {
                    eof_found = 1;
                }

            }

            data[file->data_len] = '\0';

            p = data;
            pe = p + file->data_len;
            cs |= execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
            file->data_len = 0;

            // Prepare status for next batch
            status->current_batch = vcf_batch_new(batch_size);
        }
    }

    // Insert the last batch
    // TODO this should not be neccessary because it is now inserted in execute_vcf_ragel_machine
//     if (!vcf_batch_is_empty(status->current_batch))
//     {
//         list_item_t *item = list_item_new(file->num_records, 1, status->current_batch);
//         list_insert_item(item, batches_list);
//         printf("Batch added - %zu records (last)\n", status->current_batch->records->size);
//     }

    if ( cs ) {
        LOG_INFO("Last state was not the expected");
    } 

    LOG_INFO_F("Records read = %zu\n", status->num_records);
    LOG_INFO_F("Samples per record = %zu\n", file->num_samples);

    // Free status->current_xxx pointers if not needed in another module
    vcf_reader_status_free(status);

    return cs ;
}

int vcf_read_and_parse_bytes(list_t *batches_list, size_t batch_size, vcf_file_t *file, int read_samples) {
    int cs = 0;
    char *p, *pe;

//     printf("batch size = %zu\nin approx lines = %zu\n", batch_size, batch_size / 1000);
    vcf_reader_status *status = vcf_reader_status_new(0, read_samples, 0);
    
    if (mmap_vcf) {
        LOG_DEBUG("Using mmap for file loading\n");
        p = file->data;
        pe = p + file->data_len;
        cs = execute_vcf_ragel_machine(p, pe, batches_list, 0, file, status);
    } else {
        LOG_DEBUG("Using file-IO functions for file loading\n");
        size_t max_len = 256;
        int eof_found = 0;
        char *aux;

        // Read text of a batch and call ragel parser in a loop
        while (!eof_found) {
            char *data = (char*) calloc (max_len, sizeof(char));
            int c = 0;
            int lines = 0;

            for (int i = 0; !eof_found; i++) {
                c = fgetc(file->fd);
                
                if (c != EOF) {
                    max_len = consume_input(c, &data, max_len, i);
                    if (c == '\n') {
                        lines++;
                        if (i >= batch_size) {
                            break;
                        }
                    }
                    (file->data_len)++;
                } else {
                    eof_found = 1;
                }

            }

            printf("batch lines = %d\n", lines);
            data[file->data_len] = '\0';

            p = data;
            pe = p + file->data_len;
            cs |= execute_vcf_ragel_machine(p, pe, batches_list, 0, file, status);
            file->data_len = 0;

            // Prepare status for next batch
            status->current_batch = vcf_batch_new(500);
        }
    }

    // Insert the last batch
    // TODO this should not be neccessary because it is now inserted in execute_vcf_ragel_machine
//     if (!vcf_batch_is_empty(status->current_batch))
//     {
//         list_item_t *item = list_item_new(file->num_records, 1, status->current_batch);
//         list_insert_item(item, batches_list);
//         printf("Batch added - %zu records (last)\n", status->current_batch->records->size);
//     }

    if ( cs ) {
        LOG_INFO("Last state was not the expected");
    } 

    LOG_INFO_F("Records read = %zu\n", status->num_records);
    LOG_INFO_F("Samples per record = %zu\n", file->num_samples);

    // Free status->current_xxx pointers if not needed in another module
    vcf_reader_status_free(status);

    return cs ;
}

int vcf_gzip_read_and_parse(list_t *batches_list, size_t batch_size, vcf_file_t *file, int read_samples) {
    int cs = 0;
    char *p, *pe;

    vcf_reader_status *status = vcf_reader_status_new(batch_size, read_samples, 0);
    
    LOG_DEBUG("Using file-IO functions for file loading\n");

    size_t max_len = 256;
    int eof_found = 0;
    int c = 0, i = 0, lines = 0;
    char *aux;
    char *data = (char*) calloc (max_len, sizeof(char));

    // ZLIB variables
    int ret;
    unsigned have = 0, consumed = 0;
    z_stream strm;
    unsigned char in[CHUNK];
    unsigned char out[CHUNK];

    // ZLIB stream initialization
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = 0;
    strm.next_in = Z_NULL;
    ret = inflateInit2 (&strm, 15 + 32);    // Using inflateInit2 for GZIP support
    if (ret != Z_OK) {
        LOG_ERROR("gzipped file could not be decompressed");
        return 1;
    }


    do {
        strm.avail_in = fread(in, 1, CHUNK, file->fd);
        if (ferror(file->fd)) {
            (void)inflateEnd(&strm);
            return Z_ERRNO;
        }
        if (strm.avail_in == 0)
            break;
        strm.next_in = in;

        /* run inflate() on input until output buffer not full */
        do {
            strm.avail_out = CHUNK;
            strm.next_out = out;
            ret = inflate(&strm, Z_NO_FLUSH);
            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
            switch (ret) {
            case Z_NEED_DICT:
                ret = Z_DATA_ERROR;     /* and fall through */
            case Z_DATA_ERROR:
            case Z_MEM_ERROR:
                (void)inflateEnd(&strm);
                return ret;
            }
            have = CHUNK - strm.avail_out;
            
            for (consumed = 0; consumed < have && !eof_found; consumed++) {
                c = out[consumed];

                if (c != EOF) {
                    max_len = consume_input(c, &data, max_len, i);
                    if (c == '\n') {
                        lines++;
                    }
                    i++;
                    (file->data_len)++;
                } else {
                    eof_found = 1;
                }

                // Process batch
                if (lines == batch_size) {
                    data[file->data_len] = '\0';
                    p = data;
                    pe = p + file->data_len;
                    cs |= execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
                    file->data_len = 0;

                    // Setup for next batch
                    status->current_batch = vcf_batch_new(batch_size);
                    i = 0;
                    lines = 0;
                    data = (char*) calloc (max_len, sizeof(char));
                }
            }

        } while (strm.avail_out == 0);

        /* done when inflate() says it's done */
    } while (ret != Z_STREAM_END);

    // Consume last batch
    if (lines > 0 && lines < batch_size) {
        data[file->data_len] = '\0';
        p = data;
        pe = p + file->data_len;
        cs |= execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
        file->data_len = 0;
    }

    if ( cs ) {
        LOG_INFO("Last state was not the expected");
    } 

    LOG_INFO_F("Records read = %zu\n", status->num_records);
    LOG_INFO_F("Samples per record = %zu\n", file->num_samples);

    // Free status->current_xxx pointers if not needed in another module
    vcf_reader_status_free(status);

    /* clean up and return */
    (void)inflateEnd(&strm);

    return cs ;
}

int vcf_gzip_read_and_parse_bytes(list_t *batches_list, size_t batch_size, vcf_file_t *file, int read_samples) {
    int cs = 0;
    char *p, *pe;

    vcf_reader_status *status = vcf_reader_status_new(0, read_samples, 0);
    
    LOG_DEBUG("Using file-IO functions for file loading\n");

    size_t max_len = 256;
    int eof_found = 0;
    int c = 0, i = 0, lines = 0;
    char *aux;
    char *data = (char*) calloc (max_len, sizeof(char));

    // ZLIB variables
    int ret;
    unsigned have = 0, consumed = 0;
    z_stream strm;
    unsigned char in[CHUNK];
    unsigned char out[CHUNK];

    // ZLIB stream initialization
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = 0;
    strm.next_in = Z_NULL;
    ret = inflateInit2 (&strm, 15 + 32);    // Using inflateInit2 for GZIP support
    if (ret != Z_OK) {
        LOG_ERROR("gzipped file could not be decompressed");
        return 1;
    }


    do {
        strm.avail_in = fread(in, 1, CHUNK, file->fd);
        if (ferror(file->fd)) {
            (void)inflateEnd(&strm);
            return Z_ERRNO;
        }
        if (strm.avail_in == 0)
            break;
        strm.next_in = in;

        /* run inflate() on input until output buffer not full */
        do {
            strm.avail_out = CHUNK;
            strm.next_out = out;
            ret = inflate(&strm, Z_NO_FLUSH);
            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
            switch (ret) {
            case Z_NEED_DICT:
                ret = Z_DATA_ERROR;     /* and fall through */
            case Z_DATA_ERROR:
            case Z_MEM_ERROR:
                (void)inflateEnd(&strm);
                return ret;
            }
            have = CHUNK - strm.avail_out;
            
            for (consumed = 0; consumed < have && !eof_found; consumed++) {
                c = out[consumed];

                if (c != EOF) {
                    max_len = consume_input(c, &data, max_len, i);
                    i++;
                    (file->data_len)++;
                    if (c == '\n') {
                        lines++;

                        // Process batch
                        if (i >= batch_size) {
                            data[i+1] = '\0';
                            p = data;
                            pe = p + file->data_len;
                            cs |= execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
                            file->data_len = 0;

                            // Setup for next batch
                            status->current_batch = vcf_batch_new(500);
                            i = 0;
                            lines = 0;
                            data = (char*) calloc (max_len, sizeof(char));
                        }
                    }

                } else {
                    eof_found = 1;
                }
            }

        } while (strm.avail_out == 0);

        /* done when inflate() says it's done */
    } while (ret != Z_STREAM_END);

    // Consume last batch
    if (i > 0) {
        data[i+1] = '\0';
        p = data;
        pe = p + file->data_len;
        cs |= execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
    }

    if ( cs ) {
        LOG_INFO("Last state was not the expected");
    } 

    LOG_INFO_F("Records read = %zu\n", status->num_records);
    LOG_INFO_F("Samples per record = %zu\n", file->num_samples);

    // Free status->current_xxx pointers if not needed in another module
    vcf_reader_status_free(status);

    /* clean up and return */
    (void)inflateEnd(&strm);

    return cs ;
}


/* **********************************************
 *                  Only reading                *
 * **********************************************/

int vcf_light_read(list_t *batches_list, size_t batch_size, vcf_file_t *file) {
    LOG_DEBUG("Using file-IO functions for file loading\n");

    size_t max_len = 256;
    int eof_found = 0;
    char *aux;

    // Read text of a batch and call ragel parser in a loop
    while (!eof_found) {
        char *data = (char*) calloc (max_len, sizeof(char));
        int c = 0;
        int lines = 0;

        for (int i = 0; !eof_found && lines < batch_size; i++) {
            c = fgetc(file->fd);

            if (c != EOF) {
                max_len = consume_input(c, &data, max_len, i);
                if (c == '\n') {
                    lines++;
                }
            } else {
                eof_found = 1;
            }
        }

        list_item_t *item = list_item_new(file->num_records, 1, data);
        list_insert_item(item, batches_list);
//             printf("Text batch inserted = '%s'\n", data);
    }

    return 0;
}

int vcf_light_read_bytes(list_t *batches_list, size_t batch_size, vcf_file_t *file) {
    LOG_DEBUG("Using file-IO functions for file loading\n");

    size_t max_len = 256;
    int eof_found = 0;
    int last_idx = 0;
    int i = 0;

    // Read text of a batch and call ragel parser in a loop
    while (!eof_found) {
        char *data = (char*) calloc (max_len, sizeof(char));
        int c = 0;

        for (i = 0; !eof_found; i++) {
            c = fgetc(file->fd);

            if (c != EOF) {
                max_len = consume_input(c, &data, max_len, i);
                if (c == '\n' && i >= batch_size) {
                    break;
                }
            } else {
                eof_found = 1;
            }
        }

        data[i+1] = '\0';

        // Enqueue current batch
        list_item_t *item = list_item_new(file->num_records, 1, data);
        list_insert_item(item, batches_list);
//             printf("Text batch inserted = '%s'\n", data);
    }

    return 0;
}

int vcf_gzip_light_read(list_t *batches_list, size_t batch_size, vcf_file_t *file) {
    LOG_DEBUG("Using file-IO functions for file loading\n");

    size_t max_len = 256;
    int eof_found = 0;
    int c = 0, i = 0, lines = 0;
    char *aux;
    char *data = (char*) calloc (max_len, sizeof(char));

    // ZLIB variables
    int ret;
    unsigned have;
    z_stream strm;
    unsigned char in[CHUNK];
    unsigned char out[CHUNK];

    // ZLIB stream initialization
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = 0;
    strm.next_in = Z_NULL;
    ret = inflateInit2 (&strm, 15 + 32);    // Using inflateInit2 for GZIP support
    if (ret != Z_OK) {
        LOG_ERROR("gzipped file could not be decompressed");
        return 1;
    }


    do {
        strm.avail_in = fread(in, 1, CHUNK, file->fd);
        if (ferror(file->fd)) {
            (void)inflateEnd(&strm);
            return Z_ERRNO;
        }
        if (strm.avail_in == 0)
            break;
        strm.next_in = in;

        /* run inflate() on input until output buffer not full */
        do {
            strm.avail_out = CHUNK;
            strm.next_out = out;
            ret = inflate(&strm, Z_NO_FLUSH);
            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
            switch (ret) {
            case Z_NEED_DICT:
                ret = Z_DATA_ERROR;     /* and fall through */
            case Z_DATA_ERROR:
            case Z_MEM_ERROR:
                (void)inflateEnd(&strm);
                return ret;
            }
            have = CHUNK - strm.avail_out;
            
            for (int j = 0; j < have && !eof_found; j++) {
                c = out[j];

                if (c != EOF) {
                    max_len = consume_input(c, &data, max_len, i);
                    if (c == '\n') {
                        lines++;
                    }
                    i++;
                    (file->data_len)++;
                } else {
                    eof_found = 1;
                }

                // Process batch
                if (lines == batch_size) {
                    list_item_t *item = list_item_new(file->num_records, 1, data);
                    list_insert_item(item, batches_list);

                    // Setup for next batch
                    i = 0;
                    lines = 0;
                    data = (char*) calloc (max_len, sizeof(char));
                }
            }

        } while (strm.avail_out == 0);

        /* done when inflate() says it's done */
    } while (ret != Z_STREAM_END);

    // Consume last batch
    if (lines > 0 && lines < batch_size) {
        list_item_t *item = list_item_new(file->num_records, 1, data);
        list_insert_item(item, batches_list);
    }

    /* clean up and return */
    (void)inflateEnd(&strm);
    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
}

int vcf_gzip_light_read_bytes(list_t *batches_list, size_t batch_size, vcf_file_t *file) {
    LOG_DEBUG("Using file-IO functions for file loading\n");

    size_t max_len = 256;
    int eof_found = 0;
    int c = 0, i = 0, lines = 0;
    char *aux;
    char *data = (char*) calloc (max_len, sizeof(char));

    // ZLIB variables
    int ret;
    unsigned have;
    z_stream strm;
    unsigned char in[CHUNK];
    unsigned char out[CHUNK];

    // ZLIB stream initialization
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = 0;
    strm.next_in = Z_NULL;
    ret = inflateInit2 (&strm, 15 + 32);    // Using inflateInit2 for GZIP support
    if (ret != Z_OK) {
        LOG_ERROR("gzipped file could not be decompressed");
        return 1;
    }


    do {
        strm.avail_in = fread(in, 1, CHUNK, file->fd);
        if (ferror(file->fd)) {
            (void)inflateEnd(&strm);
            return Z_ERRNO;
        }
        if (strm.avail_in == 0)
            break;
        strm.next_in = in;

        /* run inflate() on input until output buffer not full */
        do {
            strm.avail_out = CHUNK;
            strm.next_out = out;
            ret = inflate(&strm, Z_NO_FLUSH);
            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
            switch (ret) {
            case Z_NEED_DICT:
                ret = Z_DATA_ERROR;     /* and fall through */
            case Z_DATA_ERROR:
            case Z_MEM_ERROR:
                (void)inflateEnd(&strm);
                return ret;
            }
            have = CHUNK - strm.avail_out;
            
            for (int j = 0; j < have && !eof_found; j++) {
                c = out[j];

                if (c != EOF) {
                    max_len = consume_input(c, &data, max_len, i);
                    i++;
                    (file->data_len)++;
                    if (c == '\n') {
                        lines++;

                        // Process batch
                        if (i >= batch_size) {
                            data[i+1] = '\0';
                            list_item_t *item = list_item_new(file->num_records, 1, data);
                            list_insert_item(item, batches_list);

                            // Setup for next batch
                            i = 0;
                            lines = 0;
                            data = (char*) calloc (max_len, sizeof(char));
                        }
                    }

                } else {
                    eof_found = 1;
                }
            }

        } while (strm.avail_out == 0);

        /* done when inflate() says it's done */
    } while (ret != Z_STREAM_END);

    // Consume last batch
//     if (lines > 0 && lines < batch_size) {
    if (i > 0) {
        data[i+1] = '\0';
        list_item_t *item = list_item_new(file->num_records, 1, data);
        list_insert_item(item, batches_list);
    }

    /* clean up and return */
    (void)inflateEnd(&strm);
    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
}


/* **********************************************
 *      Only reading from multiple files        *
 * **********************************************/

int vcf_light_multiread(list_t **batches_list, size_t batch_size, vcf_file_t **files, size_t num_files) {
    LOG_DEBUG("Using file-IO functions for file loading\n");

    // Initialize file-private variables
    size_t max_len[num_files];
    
    for (int i = 0; i < num_files; i++) {
        max_len[i] = 256;
        files[i]->data_len = 0;
    }
    
//     char *data = NULL;
    __ssize_t line_len = 0;
    char *line = NULL;
    char *aux;
    
    int num_eof_found = 0;
    int eof_found[num_files];
    memset(eof_found, 0, num_files * sizeof(int));

    // Read text of a batch and call ragel parser in a loop
    while (num_eof_found < num_files) {
        // Read text of each file
        for (int f = 0; f < num_files; f++) {
            if (eof_found[f]) {
                printf("EOF found in file %d\n", f);
                continue;
            }

            char *data = (char*) calloc (max_len[f], sizeof(char));

            for (int i = 0; i < batch_size && !eof_found[f]; i++) {
                line_len = getline(&line, &line_len, files[f]->fd);
                if (line_len != -1) {
                    LOG_DEBUG_F("#%d Line (len %zu): %s", i, line_len, line);
                    // Line too long to be stored in data, realloc
                    if (files[f]->data_len + line_len + 1 > max_len[f]) {
                        aux = realloc(data, max_len[f] + line_len * 20);
                        if (aux) {
                            data = aux;
                            max_len[f] += line_len * 20;
                        } else {
                            LOG_FATAL("Could not allocate enough memory for reading input VCF file\n");
                        }
                    }
                    // Concat previous data with new line
                    strncat(data, line, line_len);
                    files[f]->data_len += line_len;
                } else {
                    eof_found[f] = 1;
                    num_eof_found++;
                    list_decr_writers(batches_list[f]);
                }
            }

            files[f]->data_len = 0;

            list_item_t *item = list_item_new(files[f]->num_records, 1, data);
            list_insert_item(item, batches_list[f]);
            printf("[%d] Text batch inserted\n", f);
    //             printf("Text batch inserted = '%s'\n", data);
        }
    }

    if (line != NULL) { free(line); }

    return 0;
}



/* **********************************************
 *              Auxiliary functions             *
 * **********************************************/

size_t consume_input(int c, char **data, size_t max_len, int position_in_data) {
    (*data)[position_in_data] = c;
    // Text too long to be stored in 'data', realloc
    if (position_in_data == max_len - 1) {
        char *aux = realloc(*data, max_len + 10000);
        if (aux) {
            *data = aux;
            return max_len + 10000;
        } else {
            LOG_FATAL("Could not allocate enough memory for reading input VCF file\n");
        }
    }
    return max_len;
}
