#include "vcf_reader.h"

%%{
    machine vcf;
    write data;


    number      = (digit)+ ("." (digit)+)? ;
    bases       = ("A" | "C" | "G" | "T" | "N")+ ;
    identifier  = (alnum)+ ;


    #########################################
    #       File format     #
    #########################################

    # File format rules
    format_name = (alnum | punct)+ ;
    format_start    = "fileformat" ;
    fileformat  = "##" @{ fcall fileformat_scan; } ;

    # File format scanner
    fileformat_scan := |*
        format_start @ 2 ;
        
        format_name @ 1 => { 
            char *fileformat = (char*) calloc (te-ts+1, sizeof(char));
            strncat(fileformat, ts, te-ts);
            set_file_format(fileformat, file);
        };
        
        "#" @ 3 ;
        
        "=" @ 3 ;
        
        "\n" @ 3    => { fret; };
        
        space;
    *|;


    #########################################
    #                 Header                #
    #########################################

    # Header rules
    header_id   = identifier "=<" ;
    field_id    = identifier "=" ;
    field_value = (print - (">" | "," ))+ | "\"" (print - ">")+ "\"" ;
    header      = ("##" @{ fcall header_scan; })+ ;

    # Header scanner
    header_scan := |*
        header_id @ 5   => {
            char *header_id = get_token(ts, te-2);
            set_header_entry_name(header_id, status->current_header_entry);
        };
        
        field_id @ 5    => {
            char *field_id = get_token(ts, te-1);
            if (status->current_header_entry->name != NULL)
            {
                add_header_entry_key(field_id, status->current_header_entry);
            } else {
                // Entries like ##reference=some_text_here
                status->current_header_entry = create_header_entry();
                set_header_entry_name(field_id, status->current_header_entry);
            }
        };
        
        field_value @ 4 => {
            // Remove quotation marks if necessary
            char *start = ts, *end = te;
            if (*ts == '"') start = ts + 1;
            if (*(te-1) == '"') end = te - 1;
            
            char *field_value = get_token(start, end);
            add_header_entry_value(field_value, status->current_header_entry);
        };
        
        "=<" @ 6    => {
            LOG_DEBUG(" =< ");
        };
        
        ">" @ 6 {
            LOG_DEBUG(" } ");
        };
        
        "," @ 6     => {
            LOG_DEBUG(" , ");
        };
        
        "\n"        => {
            add_header_entry(status->current_header_entry, file);
            status->current_header_entry = create_header_entry();
            LOG_DEBUG("\n");
            fret;
        };
        
        space;
    *|;


    #########################################
    #       Delimiter       #
    #########################################

    # Delimiter between header and records rules
    delimiter_intro = "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT" ;
    sample_name = (print - ("\n" | "\t"))+ ;
    delimiter   = delimiter_intro @{ fcall delimiter_scan; };

    # Delimiter scanner
    delimiter_scan  := |*
        sample_name => {
            char *sname = get_token(ts, te);
            add_sample_name(sname, file);
        };
        
        "\n"        => {
            LOG_DEBUG("\n");
            fret; 
        };
        
        space;
    *|;


    #########################################
    #       Records         #
    #########################################

    # Records rules
    record_chrom    = (alnum | "_")+ ;
    record_pos  = (digit)+ ;
    record_id   = (alnum)+ | "." ;
    record_ref  = bases ;
    record_alt  = (bases ("," bases)*)+ | "." | "0" | "<DEL>" ;
    record_qual = number | "." ;

    filter_value    = (alnum | "_")+ ;
    filter_entry    = filter_value ("," filter_value)* ;
    record_filter   = "." | filter_entry (";" filter_entry)* ;

    info_id     = (alnum | "_")+ ;
    info_value  = (print - space)+ ;
    info_value_list = info_value ("," info_value)* ;
    info_entry  = info_id | info_id "=" info_value_list ;
    record_info = info_entry (";" info_entry)* ;

    record_format   = (alnum)+ (":" (alnum)+)* ;
    record_sample   = (alnum | punct)+ (":" (alnum | punct)+)* ;
    record      = (record_chrom "\t" record_pos "\t" record_id "\t" record_ref "\t" record_alt "\t" record_qual "\t" record_filter "\t" record_info "\t" record_format ("\t" record_sample)+);
    records     = record ("\n" record)* ("\n")? ;

    # Records scanner
    record_scan := |*
        record_chrom    => {
            set_field(ts, te, status);
        };
        
        record_pos  => {
            set_field(ts, te, status);
        };
        
        record_id   => {
            set_field(ts, te, status);
        };
        
        record_ref  => {
            set_field(ts, te, status);
        };
        
        record_alt  => {
            set_field(ts, te, status);
        };
        
        record_qual     => {
            set_field(ts, te, status);
        };
        
        record_filter   => {
            set_field(ts, te, status);
        };
        
        record_info => {
            set_field(ts, te, status);
        };
        
        record_format   => {
            set_field(ts, te, status);
        };
        
        record_sample   => {
            set_field(ts, te, status);
        };
        
        "\n"        => {
            // If batch is full, add to the list of batches and create a new, empty one
            if (vcf_batch_is_full(status->current_batch))
            {
                list_item_t *item = list_item_new(file->num_records, 1, status->current_batch); 
                list_insert_item(item, batches_list);
                LOG_DEBUG_F("Batch added - %zu records\n", status->current_batch->size);
                status->current_batch = vcf_batch_new(batch_size);
            }

            // If not a blank line, add status->current record to status->current batch
            if (status->current_field != CHROM) {
                add_record_to_vcf_batch(status->current_record, status->current_batch);
                status->num_records++;
            }
            
            status->current_field = CHROM;
            status->num_samples = 0;
            LOG_DEBUG("\n");
        };
        
        space;
    *|;


    #########################################
    #               Machine                 #
    #########################################

    main        := (fileformat header delimiter)? (records >{ fhold; fcall record_scan; })? ;


}%%

static char* get_token(char *ts, char *te) {
    return strndup(ts, te-ts);
}

static void set_field(char* ts, char *te, vcf_reader_status *status) {
    char *field = get_token(ts, te);
    float quality = -1.0f;

    switch (status->current_field) {
        case CHROM:
            status->current_record = create_record();
            set_record_chromosome(field, status->current_record);
        break;
        case POS:
            set_record_position(atol(field), status->current_record);
            free(field);    // Not set as vcf_record_t variable -> not freed later
        break;
        case ID:
            set_record_id(field, status->current_record);
        break;
        case REF:
            set_record_reference(field, status->current_record);
        break;
        case ALT:
            if (!strcmp("0", field) || !strcmp("<DEL>", field)) {
                free(field);
                field = strdup(".");
            }
            set_record_alternate(field, status->current_record);
        break;
        case QUAL:
            if (strncmp(".", field, 1) != 0) {
                quality = atof(field);
            }
            set_record_quality(quality, status->current_record);
            free(field);    // Not set as vcf_record_t variable -> not freed later
        break;
        case FILTER:
            set_record_filter(field, status->current_record);
        break;
        case INFO:
            set_record_info(field, status->current_record);
        break;
        case FORMAT:
            set_record_format(field, status->current_record);
        break;
        case SAMPLE:
            if(status->store_samples) { 
                add_record_sample(field, status->current_record); 
                (status->num_samples)++;
            } else {
                free(field);    // Not added to samples -> not freed later
            }
        break;
    }

    if (status->current_field < SAMPLE) {
        status->current_field++;
    }
}

int execute_vcf_ragel_machine(char *p, char *pe, list_t *batches_list, size_t batch_size, vcf_file_t *file, vcf_reader_status *status) {
    int cs;
    char *ts, *te;
    int stack[4];
    int top, act;
    char *eof = pe;

    %%{
        write init;
        write exec;
    }%%
    
    if (status->self_contained && !vcf_batch_is_empty(status->current_batch)) {
        list_item_t *item = list_item_new(file->num_records, 1, status->current_batch);
        list_insert_item(item, batches_list);
        LOG_DEBUG_F("Batch added - %zu records (self-contained)\n", status->current_batch->size);
    }

    return cs;
}


int vcf_ragel_read(list_t *batches_list, size_t batch_size, vcf_file_t *file, int read_samples) {
    int cs;
    char *p, *pe;

    vcf_reader_status *status = new_vcf_reader_status(batch_size, read_samples, 0);
    
    if (mmap_vcf) {
        LOG_DEBUG("Using mmap for file loading\n");
        p = file->data;
        pe = p + file->data_len;
        cs = execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
    } else {
        LOG_DEBUG("Using file-IO functions for file loading\n");
        size_t max_len = 256;
        __ssize_t line_len = 0;

        char *data = (char*) malloc (max_len * sizeof(char));
        char *line = NULL;
        char *aux;
        
        int eof_found = 0;

        // Read text of a batch and call ragel parser in a loop
        while (!eof_found) {
            memset(data, 0, max_len * sizeof(char));

            for (int i = 0; i < batch_size && !eof_found; i++) {
                line_len = getline(&line, &line_len, file->fd);
                if (line_len != -1) {
    //                LOG_DEBUG_F("Line (len %zu): %s", line_len, line);
                    // Line too long to be stored in data, realloc
                    if (file->data_len + line_len + 1 > max_len) {
                        aux = realloc(data, max_len + line_len * 20);
                        if (aux) {
                            data = aux;
                            max_len += line_len * 20;
                        } else {
                            LOG_FATAL("Could not allocate enough memory for reading input VCF file\n");
                        }
                    }
                    // Concat previous data with new line
                    strncat(data, line, line_len);
                    file->data_len += line_len;
                } else {
                    eof_found = 1;
                }
            }

            p = data;
            pe = p + file->data_len;
            cs = execute_vcf_ragel_machine(p, pe, batches_list, batch_size, file, status);
            file->data_len = 0;
        }
        
        if (line != NULL) { free(line); }
        if (data != NULL) { free(data); }
    }

    // Insert the last batch
    if (!vcf_batch_is_empty(status->current_batch))
    {
        list_item_t *item = list_item_new(file->num_records, 1, status->current_batch);
        list_insert_item(item, batches_list);
        LOG_DEBUG_F("Batch added - %zu records (last)\n", status->current_batch->size);
    }

    if ( cs < %%{ write first_final; }%% ) 
    {
        LOG_INFO_F("Last state is %d, but %d was expected\n", 
                cs, %%{ write first_final; }%%);
    } 

    LOG_INFO_F("Records read = %zu\n", status->num_records);
    LOG_INFO_F("Samples per record = %zu\n", file->num_samples);

    // Free status->current_xxx pointers if not needed in another module
    vcf_header_entry_free(status->current_header_entry);   

    return cs < %%{ write first_final; }%%;
}

int vcf_light_read(list_t *batches_list, size_t batch_size, vcf_file_t *file) {
//     if (mmap_vcf) {
//         LOG_DEBUG("Using mmap for file loading\n");
//         TODO Use functions for getting the batch-size-th index of linebreak
//     } else {
    LOG_DEBUG("Using file-IO functions for file loading\n");
    size_t max_len = 256;
    __ssize_t line_len = 0;
    file->data_len = 0;

    char *data = NULL;
    char *line = NULL;
    char *aux;
    
    int eof_found = 0;

    // Read text of a batch and call ragel parser in a loop
    while (!eof_found) {
        char *data = (char*) calloc (max_len, sizeof(char));
//             memset(data, 0, max_len * sizeof(char));

        for (int i = 0; i < batch_size && !eof_found; i++) {
            line_len = getline(&line, &line_len, file->fd);
            if (line_len != -1) {
                LOG_DEBUG_F("#%d Line (len %zu): %s", i, line_len, line);
                // Line too long to be stored in data, realloc
                if (file->data_len + line_len + 1 > max_len) {
                    aux = realloc(data, max_len + line_len * 20);
                    if (aux) {
                        data = aux;
                        max_len += line_len * 20;
                    } else {
                        LOG_FATAL("Could not allocate enough memory for reading input VCF file\n");
                    }
                }
                // Concat previous data with new line
                strncat(data, line, line_len);
                file->data_len += line_len;
            } else {
                eof_found = 1;
            }
        }

        file->data_len = 0;

        list_item_t *item = list_item_new(file->num_records, 1, data);
        list_insert_item(item, batches_list);
//             printf("Text batch inserted = '%s'\n", data);

    }
    
    if (line != NULL) { free(line); }

    return 0;
}

int vcf_light_multiread(list_t **batches_list, size_t batch_size, vcf_file_t **files, size_t num_files) {
    LOG_DEBUG("Using file-IO functions for file loading\n");

    // Initialize file-private variables
    size_t max_len[num_files];
    
    for (int i = 0; i < num_files; i++) {
        max_len[i] = 256;
        files[i]->data_len = 0;
    }
    
//     char *data = NULL;
    __ssize_t line_len = 0;
    char *line = NULL;
    char *aux;
    
    int num_eof_found = 0;
    int eof_found[num_files];
    memset(eof_found, 0, num_files * sizeof(int));

    // Read text of a batch and call ragel parser in a loop
    while (num_eof_found < num_files) {
        // Read text of each file
        for (int f = 0; f < num_files; f++) {
            if (eof_found[f]) {
                printf("EOF found in file %d\n", f);
                continue;
            }

            char *data = (char*) calloc (max_len[f], sizeof(char));

            for (int i = 0; i < batch_size && !eof_found[f]; i++) {
                line_len = getline(&line, &line_len, files[f]->fd);
                if (line_len != -1) {
                    LOG_DEBUG_F("#%d Line (len %zu): %s", i, line_len, line);
                    // Line too long to be stored in data, realloc
                    if (files[f]->data_len + line_len + 1 > max_len[f]) {
                        aux = realloc(data, max_len[f] + line_len * 20);
                        if (aux) {
                            data = aux;
                            max_len[f] += line_len * 20;
                        } else {
                            LOG_FATAL("Could not allocate enough memory for reading input VCF file\n");
                        }
                    }
                    // Concat previous data with new line
                    strncat(data, line, line_len);
                    files[f]->data_len += line_len;
                } else {
                    eof_found[f] = 1;
                    num_eof_found++;
                    list_decr_writers(batches_list[f]);
                }
            }

            files[f]->data_len = 0;

            list_item_t *item = list_item_new(files[f]->num_records, 1, data);
            list_insert_item(item, batches_list[f]);
            printf("[%d] Text batch inserted\n", f);
    //             printf("Text batch inserted = '%s'\n", data);
        }
    }

    if (line != NULL) { free(line); }

    return 0;
}

vcf_reader_status *new_vcf_reader_status(size_t batch_size, int store_samples, int self_contained) {
    vcf_reader_status *status = (vcf_reader_status *) malloc (sizeof(vcf_reader_status));
    status->current_record = NULL;
    status->current_header_entry = create_header_entry();
    status->current_batch = vcf_batch_new(batch_size);
    status->current_field = CHROM;

    status->num_samples = 0;
    status->num_records = 0;

    status->store_samples = store_samples;
    status->self_contained = self_contained;

    return status;
}
