#include "vcf_reader.h"

static int store_samples;

static size_t samples = 0;
static size_t records = 0;

static vcf_record_t *current_record;
static vcf_header_entry_t *current_header_entry;
static vcf_batch_t *current_batch;

static enum VCF_Field current_field = CHROM;

%%{
	machine vcf;
	write data;
	
	
	number		= (digit)+ ("." (digit)+)? ;
	bases		= ("A" | "C" | "G" | "T" | "N")+ ;
	identifier	= (alnum)+ ;


	#########################################
	#		File format		#
	#########################################
	
	# File format rules
	format_name	= (alnum | punct)+ ;
	format_start	= "fileformat" ;
	fileformat	= "##" @{ fcall fileformat_scan; } ;
	
	# File format scanner
	fileformat_scan	:= |*
		format_start @ 2 ;
		
		format_name @ 1	=> { 
			char *fileformat = (char*) malloc ((te-ts) * sizeof(char));
			strncpy(fileformat, ts, te-ts);
			set_file_format(fileformat, file);
		};
		
		"#" @ 3 ;
		
		"=" @ 3 ;
		
		"\n" @ 3	=> { fret; };
		
		space;
	*|;


	#########################################
	#		Header			#
	#########################################
	
	# Header rules
	header_id	= identifier "=<" ;
	field_id	= identifier "=" ;
	field_value	= (print - (">" | "," ))+ | "\"" (print - ">")+ "\"" ;
	header		= ("##" @{ fcall header_scan; })+ ;
	
	# Header scanner
	header_scan	:= |*
		header_id @ 5	=> {
			char *header_id = get_token(ts, te-2);
			set_header_entry_name(header_id, current_header_entry);
		};
		
		field_id @ 5	=> {
			char *field_id = get_token(ts, te-1);
			if (current_header_entry->name != NULL)
			{
				add_header_entry_key(field_id, current_header_entry);
			} else {
				// Entries like ##reference=some_text_here
				current_header_entry = create_header_entry();
				set_header_entry_name(field_id, current_header_entry);
			}
		};
		
		field_value @ 4	=> {
			// Remove quotation marks if necessary
			char *start = ts, *end = te;
			if (*ts == '"') start = ts + 1;
			if (*(te-1) == '"') end = te - 1;
			
			char *field_value = get_token(start, end);
			add_header_entry_value(field_value, current_header_entry);
		};
		
		"=<" @ 6	=> {
			LOG_DEBUG(" =< ");
		};
		
		">" @ 6 {
			LOG_DEBUG(" } ");
		};
		
		"," @ 6 	=> {
			LOG_DEBUG(" , ");
		};
		
		"\n"		=> {
			add_header_entry(current_header_entry, file);
			current_header_entry = create_header_entry();
			LOG_DEBUG("\n");
			fret;
		};
		
		space;
	*|;

	
	#########################################
	#		Delimiter		#
	#########################################

	# Delimiter between header and records rules
	delimiter_intro = "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT" ;
	sample_name	= (print - ("\n" | "\t"))+ ;
	delimiter	= delimiter_intro @{ fcall delimiter_scan; };

	# Delimiter scanner
	delimiter_scan	:= |*
		
		sample_name	=> {
			char *sname = get_token(ts, te);
			add_sample_name(sname, file);
		};
		
		"\n"		=> {
			LOG_DEBUG("\n");
			fret; 
		};
		
		space;
	*|;


	#########################################
	#		Records			#
	#########################################

	# Records rules
	record_chrom	= (alnum | "_")+ ;
	record_pos	= (digit)+ ;
	record_id	= (alnum)+ | "." ;
	record_ref	= bases ;
	record_alt	= (bases ("," bases)*)+ | "." ;
	record_qual	= number | "." ;
	
	filter_value	= (alnum | "_")+ ;
	filter_entry	= filter_value ("," filter_value)* ;
	record_filter	= "." | filter_entry (";" filter_entry)* ;
	
	info_id		= (alnum | "_")+ ;
	info_value	= (print - space)+ ;
	info_value_list	= info_value ("," info_value)* ;
	info_entry	= info_id | info_id "=" info_value_list ;
	record_info	= info_entry (";" info_entry)* ;
	
	record_format	= (alnum)+ (":" (alnum)+)* ;
	record_sample	= (alnum | punct)+ (":" (alnum | punct)+)* ;
	record		= (record_chrom "\t" record_pos "\t" record_id "\t" record_ref "\t" record_alt "\t" record_qual "\t" record_filter "\t" record_info "\t" record_format ("\t" record_sample)+);
	records		= record ("\n" record)* ("\n")? ;
	
	# Records scanner
	record_scan	:= |*
		record_chrom	=> {
			set_field(ts, te);
		};
		
		record_pos	=> {
			set_field(ts, te);
		};
		
		record_id 	=> {
			set_field(ts, te);
		};
		
		record_ref 	=> {
			set_field(ts, te);
		};
		
		record_alt 	=> {
			set_field(ts, te);
		};
		
		record_qual 	=> {
			set_field(ts, te);
		};
		
		record_filter	=> {
			set_field(ts, te);
		};
		
		record_info	=> {
			set_field(ts, te);
		};
		
		record_format	=> {
			set_field(ts, te);
		};
		
		record_sample	=> {
			set_field(ts, te);
		};
		
		"\n"		=> {
			// If batch is full, add to the list of batches and create a new, empty one
			if (batch_is_full(current_batch))
			{
				list_item_t *item = list_item_new(file->num_records, 1, current_batch); 
				list_insert_item(item, batches_list);
				LOG_DEBUG_F("Batch added - %zu records\n", current_batch->length);
				current_batch = vcf_batch_new(batch_size);
			}

            // If not a blank line, add current record to current batch
            if (current_field != CHROM) {
                add_record_to_batch(current_record, current_batch);
                records++;
            }
            
			current_field = CHROM;
			samples = 0;
			LOG_DEBUG("\n");
		};
		
		space;
	*|;
	

	#########################################
	#		Machine			#
	#########################################

	main		:= fileformat header delimiter records >{ fhold; fcall record_scan; } ;


}%%

static char* get_token(char *ts, char *te)
{
	char *field = (char*) malloc ((te-ts+1) * sizeof(char));
	strncpy(field, ts, (te-ts));
	field[te-ts] = '\0';
	return field;
}

static void set_field(char* ts, char *te)
{
	char *field = get_token(ts, te);
	float quality = -1.0f;

	switch (current_field)
	{
		case CHROM:
			current_record = create_record();
			set_record_chromosome(field, current_record);
		break;
		case POS:
			set_record_position(atol(field), current_record);
			free(field);	// Not set as vcf_record_t variable -> not freed later
		break;
		case ID:
			set_record_id(field, current_record);
		break;
		case REF:
			set_record_reference(field, current_record);
		break;
		case ALT:
			set_record_alternate(field, current_record);
		break;
		case QUAL:
			if (strncmp(".", field, 1) != 0)
			{
				quality = atof(field);
			}
			set_record_quality(quality, current_record);
			free(field);	// Not set as vcf_record_t variable -> not freed later
		break;
		case FILTER:
			set_record_filter(field, current_record);
		break;
		case INFO:
			set_record_info(field, current_record);
		break;
		case FORMAT:
			set_record_format(field, current_record);
		break;
		case SAMPLE:
			if(store_samples) { 
                add_record_sample(field, current_record, &samples); 
            } else {
                free(field);    // Not added to samples -> not freed later
            }
		break;
	}

	if (current_field < SAMPLE)
	{
		current_field++;
	}
}

int vcf_ragel_read(list_t *batches_list, size_t batch_size, vcf_file_t *file, int read_samples)
{
	int cs;
	char *p = file->data;
	char *pe = p + file->data_len;
	char *eof = pe;
	char *ts, *te;
	int stack[4];
	int top, act;

    store_samples = read_samples;
	current_header_entry = create_header_entry();
	current_batch = vcf_batch_new(batch_size);
	
	%%{
		write init;
		write exec;
	}%% 
	
	// Insert the last batch
	if (!batch_is_empty(current_batch))
	{
		list_item_t *item = list_item_new(file->num_records, 1, current_batch); 
		list_insert_item(item, batches_list);
		LOG_DEBUG_F("Batch added - %zu records (last)\n", current_batch->length);
	}
	
	if ( cs < %%{ write first_final; }%% ) 
	{
		LOG_INFO_F("Last state is %d, but %d was expected\n", 
		       cs, %%{ write first_final; }%%);
	} 
	
	LOG_INFO_F("Records read = %zu\n", records);
	LOG_INFO_F("Samples per record = %zu\n", file->num_samples);
	
	// Free current_xxx pointers if not needed in another module
	vcf_header_entry_free(current_header_entry);
	
	return cs < %%{ write first_final; }%%;
}
