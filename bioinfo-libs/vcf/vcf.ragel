#include "vcf_reader.h"

static int store_samples;

static size_t samples = 0;
static size_t records = 0;

static vcf_record_t *current_record;
static vcf_header_entry_t *current_header_entry;
static vcf_batch_t *current_batch;

static enum VCF_Field current_field = CHROM;

%%{
	machine vcf;
	write data;
	
	
	number		= (digit)+ ("." (digit)+)? ;
	bases		= ("A" | "C" | "G" | "T" | "N")+ ;
	identifier	= (alnum)+ ;


	#########################################
	#		File format		#
	#########################################
	
	# File format rules
	format_name	= (alnum | punct)+ ;
	format_start	= "fileformat" ;
    fileformat  = "##" @{ fcall fileformat_scan; } ;
	
	# File format scanner
	fileformat_scan	:= |*
		format_start @ 2 ;
		
		format_name @ 1	=> { 
			char *fileformat = (char*) calloc (te-ts+1, sizeof(char));
			strncat(fileformat, ts, te-ts);
			set_file_format(fileformat, file);
		};
		
		"#" @ 3 ;
		
		"=" @ 3 ;
		
		"\n" @ 3	=> { fret; };
		
		space;
	*|;


	#########################################
	#		Header			#
	#########################################
	
	# Header rules
	header_id	= identifier "=<" ;
	field_id	= identifier "=" ;
	field_value	= (print - (">" | "," ))+ | "\"" (print - ">")+ "\"" ;
	header		= ("##" @{ fcall header_scan; })+ ;
	
	# Header scanner
	header_scan	:= |*
		header_id @ 5	=> {
			char *header_id = get_token(ts, te-2);
			set_header_entry_name(header_id, current_header_entry);
		};
		
		field_id @ 5	=> {
			char *field_id = get_token(ts, te-1);
			if (current_header_entry->name != NULL)
			{
				add_header_entry_key(field_id, current_header_entry);
			} else {
				// Entries like ##reference=some_text_here
				current_header_entry = create_header_entry();
				set_header_entry_name(field_id, current_header_entry);
			}
		};
		
		field_value @ 4	=> {
			// Remove quotation marks if necessary
			char *start = ts, *end = te;
			if (*ts == '"') start = ts + 1;
			if (*(te-1) == '"') end = te - 1;
			
			char *field_value = get_token(start, end);
			add_header_entry_value(field_value, current_header_entry);
		};
		
		"=<" @ 6	=> {
			LOG_DEBUG(" =< ");
		};
		
		">" @ 6 {
			LOG_DEBUG(" } ");
		};
		
		"," @ 6 	=> {
			LOG_DEBUG(" , ");
		};
		
		"\n"		=> {
			add_header_entry(current_header_entry, file);
			current_header_entry = create_header_entry();
			LOG_DEBUG("\n");
			fret;
		};
		
		space;
	*|;

	
	#########################################
	#		Delimiter		#
	#########################################

	# Delimiter between header and records rules
	delimiter_intro = "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT" ;
	sample_name	= (print - ("\n" | "\t"))+ ;
	delimiter	= delimiter_intro @{ fcall delimiter_scan; };

	# Delimiter scanner
	delimiter_scan	:= |*
        sample_name => {
			char *sname = get_token(ts, te);
			add_sample_name(sname, file);
		};
		
		"\n"		=> {
			LOG_DEBUG("\n");
			fret; 
		};
		
		space;
	*|;


	#########################################
	#		Records			#
	#########################################

	# Records rules
	record_chrom	= (alnum | "_")+ ;
	record_pos	= (digit)+ ;
	record_id	= (alnum)+ | "." ;
	record_ref	= bases ;
	record_alt	= (bases ("," bases)*)+ | "." ;
	record_qual	= number | "." ;
	
	filter_value	= (alnum | "_")+ ;
	filter_entry	= filter_value ("," filter_value)* ;
	record_filter	= "." | filter_entry (";" filter_entry)* ;
	
	info_id		= (alnum | "_")+ ;
	info_value	= (print - space)+ ;
	info_value_list	= info_value ("," info_value)* ;
	info_entry	= info_id | info_id "=" info_value_list ;
	record_info	= info_entry (";" info_entry)* ;
	
	record_format	= (alnum)+ (":" (alnum)+)* ;
	record_sample	= (alnum | punct)+ (":" (alnum | punct)+)* ;
	record		= (record_chrom "\t" record_pos "\t" record_id "\t" record_ref "\t" record_alt "\t" record_qual "\t" record_filter "\t" record_info "\t" record_format ("\t" record_sample)+);
	records		= record ("\n" record)* ("\n")? ;
	
	# Records scanner
	record_scan	:= |*
		record_chrom	=> {
			set_field(ts, te);
		};
		
		record_pos	=> {
			set_field(ts, te);
		};
		
		record_id 	=> {
			set_field(ts, te);
		};
		
		record_ref 	=> {
			set_field(ts, te);
		};
		
		record_alt 	=> {
			set_field(ts, te);
		};
		
		record_qual 	=> {
			set_field(ts, te);
		};
		
		record_filter	=> {
			set_field(ts, te);
		};
		
		record_info	=> {
			set_field(ts, te);
		};
		
		record_format	=> {
			set_field(ts, te);
		};
		
		record_sample	=> {
			set_field(ts, te);
		};
		
		"\n"		=> {
			// If batch is full, add to the list of batches and create a new, empty one
			if (vcf_batch_is_full(current_batch))
			{
				list_item_t *item = list_item_new(file->num_records, 1, current_batch); 
				list_insert_item(item, batches_list);
				LOG_DEBUG_F("Batch added - %zu records\n", current_batch->length);
				current_batch = vcf_batch_new(batch_size);
			}

            // If not a blank line, add current record to current batch
            if (current_field != CHROM) {
                add_record_to_vcf_batch(current_record, current_batch);
                records++;
            }
            
			current_field = CHROM;
			samples = 0;
			LOG_DEBUG("\n");
		};
		
		space;
	*|;
	

	#########################################
	#		Machine			#
	#########################################

    main        := (fileformat header delimiter)? (records >{ fhold; fcall record_scan; })? ;


}%%

static char* get_token(char *ts, char *te)
{
	char *field = (char*) calloc ((te-ts+1), sizeof(char));
    strncat(field, ts, (te-ts));
	return field;
}

static void set_field(char* ts, char *te) {
	char *field = get_token(ts, te);
	float quality = -1.0f;

	switch (current_field) {
		case CHROM:
			current_record = create_record();
			set_record_chromosome(field, current_record);
		break;
		case POS:
			set_record_position(atol(field), current_record);
			free(field);	// Not set as vcf_record_t variable -> not freed later
		break;
		case ID:
			set_record_id(field, current_record);
		break;
		case REF:
			set_record_reference(field, current_record);
		break;
		case ALT:
			set_record_alternate(field, current_record);
		break;
		case QUAL:
			if (strncmp(".", field, 1) != 0)
			{
				quality = atof(field);
			}
			set_record_quality(quality, current_record);
			free(field);	// Not set as vcf_record_t variable -> not freed later
		break;
		case FILTER:
			set_record_filter(field, current_record);
		break;
		case INFO:
			set_record_info(field, current_record);
		break;
		case FORMAT:
			set_record_format(field, current_record);
		break;
		case SAMPLE:
			if(store_samples) { 
                add_record_sample(field, current_record, &samples); 
            } else {
                free(field);    // Not added to samples -> not freed later
            }
		break;
	}

	if (current_field < SAMPLE) {
		current_field++;
	}
}

static int execute_ragel_machine(char *p, char *pe, list_t *batches_list, size_t batch_size, vcf_file_t *file) {
    int cs;
    char *ts, *te;
    int stack[4];
    int top, act;
    char *eof = pe;
    
    %%{
        write init;
        write exec;
    }%%
    
    return cs;
}


int vcf_ragel_read(list_t *batches_list, size_t batch_size, vcf_file_t *file, int read_samples) {
    int cs;
    char *p, *pe;

    store_samples = read_samples;
    current_header_entry = create_header_entry();
    current_batch = vcf_batch_new(batch_size);

    if (mmap_vcf) {
        LOG_DEBUG("Using mmap for file loading\n");
        p = file->data;
        pe = p + file->data_len;
        cs = execute_ragel_machine(p, pe, batches_list, batch_size, file);
    } else {
        LOG_DEBUG("Using file-IO functions for file loading\n");
        size_t max_len = 256;
        __ssize_t line_len = 0;

        char *data = (char*) malloc (max_len * sizeof(char));
        char *line = NULL;
        char *aux;
        
        int eof_found = 0;

        // Read text of a batch and call ragel parser in a loop
        while (!eof_found) {
            memset(data, 0, max_len * sizeof(char));

            for (int i = 0; i < batch_size && !eof_found; i++) {
                line_len = getline(&line, &line_len, file->fd);
                if (line_len != -1) {
    //                LOG_DEBUG_F("Line (len %zu): %s", line_len, line);
                    // Line too long to be stored in data, realloc
                    if (file->data_len + line_len + 1 > max_len) {
                        aux = realloc(data, max_len + line_len * 20);
                        if (aux) {
                            data = aux;
                            max_len += line_len * 20;
                        } else {
                            LOG_FATAL("Could not allocate enough memory for reading input VCF file\n");
                        }
                    }
                    // Concat previous data with new line
                    strncat(data, line, line_len);
                    file->data_len += line_len;
                } else {
                    eof_found = 1;
                }
            }

            p = data;
            pe = p + file->data_len;
            cs = execute_ragel_machine(p, pe, batches_list, batch_size, file);
            file->data_len = 0;
        }
        
        if (line != NULL) { free(line); }
        if (data != NULL) { free(data); }
    }

	// Insert the last batch
	if (!vcf_batch_is_empty(current_batch))
	{
		list_item_t *item = list_item_new(file->num_records, 1, current_batch);
		list_insert_item(item, batches_list);
		LOG_DEBUG_F("Batch added - %zu records (last)\n", current_batch->length);
	}
	
	if ( cs < %%{ write first_final; }%% ) 
	{
		LOG_INFO_F("Last state is %d, but %d was expected\n", 
		       cs, %%{ write first_final; }%%);
	} 
	
	LOG_INFO_F("Records read = %zu\n", records);
	LOG_INFO_F("Samples per record = %zu\n", file->num_samples);
	
	// Free current_xxx pointers if not needed in another module
	vcf_header_entry_free(current_header_entry);   
	
	return cs < %%{ write first_final; }%%;
}
