#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>

#include "../../commons/commons.h"
#include "../../commons/log.h"
#include "../../commons/system_utils.h"

#include "fastq_batch.h"
#include "fastq_batch_reader.h"
#include "fastq_batch_list.h"

//=====================================================
// functions to manage fastq read batch server
//
//=====================================================

//----------------------------------------------
// fastq batch reader new
//--------------------------------------------

fastq_batch_reader_t* fastq_batch_reader_new(char* filename, int source_id, fastq_batch_list_t* fastq_batch_list_p, unsigned long batch_size, int batch_list_max_length) {

  fastq_batch_reader_t* fastq_batch_reader_p = (fastq_batch_reader_t*) malloc(sizeof(fastq_batch_reader_t));

  // open the input file....
  //
  fastq_batch_reader_p->fastq_file_p = fastq_open(filename, "r");
  fastq_batch_reader_p->source_id = source_id;

  fastq_batch_reader_p->batch_size = batch_size;
  fastq_batch_reader_p->batch_list_max_length = batch_list_max_length;

  fastq_batch_reader_p->eof = 0;
  fastq_batch_reader_p->eof_lock = PTHREAD_MUTEX_INITIALIZER;

  fastq_batch_reader_p->alive = 1;
  fastq_batch_reader_p->alive_lock = PTHREAD_MUTEX_INITIALIZER;

  fastq_batch_reader_p->batch_list_p = fastq_batch_list_p;
  fastq_batch_list_incr_producers(fastq_batch_list_p);

  return fastq_batch_reader_p;
}

//----------------------------------------------
// fastq batch reader free
//--------------------------------------------

void fastq_batch_reader_free(fastq_batch_reader_t* fastq_batch_reader_p) {

  // close the input file and exiting....
  //
  fastq_close(fastq_batch_reader_p->fastq_file_p);
}

//----------------------------------------------
// fastq read batch thread API
//--------------------------------------------

void fastq_batch_reader_start(fastq_batch_reader_t* fastq_batch_reader_p) {

  // create and launch pthread....
  //
  //printf("launching batch server thread....\n");

  pthread_create(&(fastq_batch_reader_p->thread), NULL, fastq_batch_reader_thread_function, (void*) fastq_batch_reader_p);
}

//----------------------------------------------

unsigned int fastq_batch_reader_join(fastq_batch_reader_t* fastq_batch_reader_p) {

  // create and launch pthread....
  //
  //printf("THREAD-READ: waiting for batch server thread....\n");

  void* r;
  pthread_join(fastq_batch_reader_p->thread, &r);
  return (uintptr_t) r;
}

//----------------------------------------------
// fastq read batch next batch
// get the first item in the list of batches
//--------------------------------------------

fastq_batch_list_item_t* fastq_batch_reader_next_batch(fastq_batch_reader_t* fastq_batch_reader_p) {
  return fastq_batch_list_remove(fastq_batch_reader_p->batch_list_p);
}

//----------------------------------------------
// 'secure' set and get for eof
//--------------------------------------------

void fastq_batch_reader_set_eof(fastq_batch_reader_t* fastq_batch_reader_p, int eof) {
  pthread_mutex_lock(&(fastq_batch_reader_p->eof_lock));
  fastq_batch_reader_p->eof = eof;
  pthread_mutex_unlock(&(fastq_batch_reader_p->eof_lock));
}

int fastq_batch_reader_get_eof(fastq_batch_reader_t* fastq_batch_reader_p) {
  int eof;
  pthread_mutex_lock(&(fastq_batch_reader_p->eof_lock));
  eof = fastq_batch_reader_p->eof;
  pthread_mutex_unlock(&(fastq_batch_reader_p->eof_lock));
  return eof;
}

//----------------------------------------------
// 'secure' set and get for alive
//--------------------------------------------

void fastq_batch_reader_set_alive(fastq_batch_reader_t* fastq_batch_reader_p, int alive) {
  pthread_mutex_lock(&(fastq_batch_reader_p->alive_lock));
  fastq_batch_reader_p->alive = alive;
  pthread_mutex_unlock(&(fastq_batch_reader_p->alive_lock));
}

int fastq_batch_reader_get_alive(fastq_batch_reader_t* fastq_batch_reader_p) {
  int alive;
  pthread_mutex_lock(&(fastq_batch_reader_p->alive_lock));
  alive = fastq_batch_reader_p->alive;
  pthread_mutex_unlock(&(fastq_batch_reader_p->alive_lock));
  return alive;
}

//-----------------------------------------------------
// read batch thread function
//
// this thread reads read from disk, and save them
// into a list to be processed by the gpu thread
//-----------------------------------------------------
void* fastq_batch_reader_thread_function(void* param_p) {
	unsigned int total_reads = 0;

	// micro seconds to wait
	unsigned int usecs = 1000;	// 1ms

	timevars();
// 	struct timespec ts;
// 	ts.tv_sec = 1;
// 	ts.tv_nsec = 0;

	// Cast param_p to 'fastq_batch_reader_t'
	//
	fastq_batch_reader_t* fastq_batch_reader_p = (fastq_batch_reader_t*) param_p;

	printf("Thread-READ: START, for file %s\n", fastq_batch_reader_p->fastq_file_p->filename);

	fastq_batch_reader_set_eof(fastq_batch_reader_p, 0);
	fastq_batch_reader_set_alive(fastq_batch_reader_p, 1);

	int num_reads = 0, num_batchs = 0;
	fastq_batch_t* fastq_batch_p;
	fastq_batch_list_item_t *item_p = NULL;

//  if (time_on) { start_timer(t1_read); }
	while (true) {
		// printf("---> begin fastq extraction... ");

		// allocationg memory for the current fastq batch
		LOG_DEBUG("Thread-READ: Before allocating memory for fastq_batch_p...");
		fastq_batch_p = (fastq_batch_t*) malloc(sizeof(fastq_batch_t));
		memset(fastq_batch_p, 0, sizeof(fastq_batch_t));

		fastq_batch_init(fastq_batch_p, fastq_batch_reader_p->batch_size);
		fastq_batch_p->source_id = fastq_batch_reader_p->source_id;

		// debugging the list
		while ((fastq_batch_list_length(fastq_batch_reader_p->batch_list_p) >= fastq_batch_reader_p->batch_list_max_length) ||
(fastq_batch_reader_p->batch_list_p->length_by_source_id[fastq_batch_reader_p->source_id] >	(fastq_batch_reader_p->batch_list_max_length/2)))  {
			// Delay for a bit
			//printf("Thread-READ: go to sleep for a while...\n");
			sched_yield();
// 			nanosleep (&ts, NULL);
			usleep(usecs);
		}

		if (time_flag) {
			start_timer(t1_read);
		}

		// read reads from file
		num_reads = fastq_read_batch_max_size(fastq_batch_p, fastq_batch_reader_p->batch_size, fastq_batch_reader_p->fastq_file_p);
		total_reads += num_reads;

		// if no reads exit....
		if(num_reads == 0) {
			fastq_batch_free(fastq_batch_p);
			free(fastq_batch_p);
			break;
		}

		// otherwise, create a new batch object..
		item_p = (fastq_batch_list_item_t*) malloc(sizeof(fastq_batch_list_item_t));
		item_p->batch_p = fastq_batch_p;
		item_p->id = num_batchs;

		// fastq_batch_print(fastq_batch_p, reader_fd);
		// and insert this batch to the list
		// don't forget to SYNCHRONIZE in order to
		// access to the read_batch_list structure !!!!
		fastq_batch_list_insert(item_p, fastq_batch_reader_p->batch_list_p);

		// printf("---> after fastq batch insertion... ");
		// get_free_memory();
		// printf("++++++ inserting in read list (source, batch) = (%i, %i), (batchs, total reads) = (%i, %i), from file %s\n", item_p->batch_p->source_id, item_p->id, num_batchs, total_reads,
		fastq_batch_reader_p->fastq_file_p->filename);

		printf("Thread-READ: ....reading batch %i (%i reads), done !!!!\n", num_batchs, num_reads);

		num_batchs++;

		if(verbose) {
			stop_timer(t1_read, t2_read, read_time);
		}

	} // end of batch loop

	//printf("Number of read batchs: %i\n", num_batchs);

	fastq_batch_reader_set_eof(fastq_batch_reader_p, 1);
	fastq_batch_reader_set_alive(fastq_batch_reader_p, 0);
	fastq_batch_list_decr_producers(fastq_batch_reader_p->batch_list_p);

	//  if (time_on) { stop_timer(t1_read, t2_read, read_time); }
	printf("Thread-READ: END (%i reads)\n", total_reads);

	// debugging the list
	//
	//printf("batch_list_length: %i\n", fastq_batch_list_length(&(fastq_batch_reader_p->batch_list)));
	//printf("items:\n");
	//fastq_batch_list_print(fastq_batch_reader_p->batch_list_p);

	pthread_exit((void*)total_reads);
}
