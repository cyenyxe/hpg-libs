#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "fastq_batch.h"
#include "fastq_file.h"

#include "../../commons/commons.h"
#include "../../commons/file_utils.h"
#include "../../commons/string_utils.h"

//====================================================================================
//  fastq.c
//  fastq methods
//====================================================================================

fastq_file_t *fastq_open(char *filename) {
	return fastq_open(filename, (char*)"r");
}


//-----------------------------------------------------
// fastq_open
//-----------------------------------------------------
fastq_file_t *fastq_open(char *filename, char *mode) {

	FILE *fd = fopen(filename, mode);
	if (fd == NULL) {
		printf("Error opening file: %s, mode (%s) !!!!!\n", filename, mode);
		return NULL;
	}

	fastq_file_t *fq_file = (fastq_file_t *) malloc(sizeof(fastq_file_t));

	fq_file->filename = filename;
	fq_file->mode = mode;
	fq_file->fd = fd;
	//fq_file->num_reads = fastq_countlines(filename, 512)/4;

	return fq_file;
}

//-----------------------------------------------------
// fastq_read (1 read)
//-----------------------------------------------------
int fastq_read(fastq_read_t *read, fastq_file_t *fq_file) {
	return fastq_read(read, 1, fq_file);
}

//-----------------------------------------------------
// fastq_read (num_reads)
//-----------------------------------------------------
int fastq_read(fastq_read_t *buffer_fq_reads, int num_reads, fastq_file_t *fq_file) {

	int count = 0;
	char header1[MAX_READ_ID_LENGTH];
	char sequence[MAX_READ_SEQUENCE_LENGTH];
	char header2[MAX_READ_ID_LENGTH];
	char qualities[MAX_READ_SEQUENCE_LENGTH];
	int header_length, sequence_length, quality_length;

// 	buffer_fq_reads = (fastq_read_t*)malloc(sizeof(fastq_read_t) * num_reads);
// 	buffer_fq_reads = (fastq_read_t*)malloc(sizeof(fastq_read_t) * num_reads);
	while(count < num_reads && fgets(header1, MAX_READ_ID_LENGTH, fq_file->fd) != NULL) {

		fgets(sequence, MAX_READ_SEQUENCE_LENGTH, fq_file->fd);
		fgets(header2, MAX_READ_ID_LENGTH, fq_file->fd);
		fgets(qualities, MAX_READ_SEQUENCE_LENGTH, fq_file->fd);

		header_length = strlen(header1);
		sequence_length = strlen(sequence);
		quality_length = strlen(qualities);

		chomp(header1, header_length-1);
		chomp(sequence, sequence_length-1);
		chomp(qualities, quality_length-1);

		buffer_fq_reads[count].id = (char*)malloc(sizeof(char) * header_length);
		buffer_fq_reads[count].sequence = (char*)malloc(sizeof(char) * sequence_length);
		buffer_fq_reads[count].quality = (char*)malloc(sizeof(char) * quality_length);

		strcpy(buffer_fq_reads[count].id, header1);
		strcpy(buffer_fq_reads[count].sequence, sequence);
		strcpy(buffer_fq_reads[count].quality, qualities);
// 		strcpy(buffer_fq_reads[count].size, header_length+sequence_length+quality_length);

		count++;
	}

	return count;
}

//-----------------------------------------------------
// fastq_read_max_size (max_size)
//-----------------------------------------------------
int fastq_read_max_size(fastq_read_t *buffer_fq_reads, unsigned long max_size, fastq_file_t *fq_file) {

	int count = 0;
	unsigned long accumulated_size = 0;
	char header1[MAX_READ_ID_LENGTH];
	char sequence[MAX_READ_SEQUENCE_LENGTH];
	char header2[MAX_READ_ID_LENGTH];
	char qualities[MAX_READ_SEQUENCE_LENGTH];
	int header_length, sequence_length, quality_length;

// 	buffer_fq_reads = (fastq_read_t*)malloc(sizeof(fastq_read_t) * num_reads);
// 	buffer_fq_reads = (fastq_read_t*)malloc(sizeof(fastq_read_t) * num_reads);
	while(accumulated_size <= max_size && fgets(header1, MAX_READ_ID_LENGTH, fq_file->fd) != NULL) {

		fgets(sequence, MAX_READ_SEQUENCE_LENGTH, fq_file->fd);
		fgets(header2, MAX_READ_ID_LENGTH, fq_file->fd);
		fgets(qualities, MAX_READ_SEQUENCE_LENGTH, fq_file->fd);

		header_length = strlen(header1);
		sequence_length = strlen(sequence);
		quality_length = strlen(qualities);

		chomp(header1, header_length-1);
		chomp(sequence, sequence_length-1);
		chomp(qualities, quality_length-1);

		buffer_fq_reads[count].id = (char*)malloc(sizeof(char) * header_length);
		buffer_fq_reads[count].sequence = (char*)malloc(sizeof(char) * sequence_length);
		buffer_fq_reads[count].quality = (char*)malloc(sizeof(char) * quality_length);

		strcpy(buffer_fq_reads[count].id, header1);
		strcpy(buffer_fq_reads[count].sequence, sequence);
		strcpy(buffer_fq_reads[count].quality, qualities);
 		//strcpy(buffer_fq_reads[count].size, header_length + sequence_length + quality_length);
		accumulated_size += header_length + sequence_length + quality_length;

		count++;
	}

	return count;
}

int fastq_read_batch_max_size(fastq_batch_t *buffer_fq_read_batch, unsigned long max_size, fastq_file_t *fq_file) {

	unsigned long accumulated_size = 0;

	char header1[MAX_READ_ID_LENGTH];
	char sequence[MAX_READ_SEQUENCE_LENGTH];
	char header2[MAX_READ_ID_LENGTH];
	char qualities[MAX_READ_SEQUENCE_LENGTH];
	int header_length, sequence_length, quality_length;

	int count = 0;
	buffer_fq_read_batch->header_indices[count] = 0;
	buffer_fq_read_batch->data_indices[count] = 0;

	//CUDA_LOG_INFO("fastq_read_batch_max_size: before while");
	//(count*sizeof(int) <= buffer_fq_read_batch->data_indices_size-1024) &&
	while(accumulated_size <= (max_size-1024) && fgets(header1, MAX_READ_ID_LENGTH, fq_file->fd) != NULL) {

		fgets(sequence, MAX_READ_SEQUENCE_LENGTH, fq_file->fd);
		fgets(header2, MAX_READ_ID_LENGTH, fq_file->fd);
		fgets(qualities, MAX_READ_SEQUENCE_LENGTH, fq_file->fd);

		header_length = strlen(header1);
		sequence_length = strlen(sequence);
		quality_length = strlen(qualities);

		if(sequence_length == quality_length) {
			// remove '\n' character, now length includes '\0' character
			remove_trailing_newline(header1, header_length-1);
			remove_trailing_newline(sequence, sequence_length-1);
			remove_trailing_newline(qualities, quality_length-1);

			count++;

			strcpy(&(buffer_fq_read_batch->header[buffer_fq_read_batch->header_indices[count-1]]), header1);

 			strcpy(&(buffer_fq_read_batch->data[buffer_fq_read_batch->data_indices[count-1]]), sequence);
			strcpy(&(buffer_fq_read_batch->data[buffer_fq_read_batch->data_indices[count-1] + sequence_length]), qualities);

			if (count*sizeof(int) >= buffer_fq_read_batch->data_indices_size) {

			  // maybe we MUST USE the realloc function
			  //
			  int size = (count + 100) * sizeof(int);
			  //printf("****************************************************************************************** %s\n", header1);
			  //printf("Too many reads (%i) for data indices, allocated memory = %i, necessary memory = %i, resizing to %i bytes\n", count, buffer_fq_read_batch->data_indices_size, count*sizeof(int), size);
			  //printf("****************************************************************************************** %s\n", header1);

			  // that's for data indices...
			  //
			  int* p = (int*) malloc(size);
			  memset((void *) p, 0, size);
			  memcpy((void*) p, (void*) buffer_fq_read_batch->data_indices, count * sizeof(int));

			  free(buffer_fq_read_batch->data_indices);

			  buffer_fq_read_batch->data_indices = p;

			  // and now for header indices...
			  //
			  p = (int*) malloc(size);
			  memset((void *) p, 0, size);
			  memcpy((void*) p, (void*) buffer_fq_read_batch->header_indices, count * sizeof(int));

			  free(buffer_fq_read_batch->header_indices);

			  buffer_fq_read_batch->header_indices = p;

  			  buffer_fq_read_batch->data_indices_size = size;

			  //buffer_fq_read_batch->data_indices_size = size;

			  //fprintf(reader_fd, "%s\n", header1);
			  //fprintf(reader_fd, "%s\n", sequence);
			  //fprintf(reader_fd, "+\n");
			  //fprintf(reader_fd, "%s\n", qualities);

			}
			buffer_fq_read_batch->data_indices[count] = buffer_fq_read_batch->data_indices[count-1] + sequence_length + quality_length;
			buffer_fq_read_batch->header_indices[count] = buffer_fq_read_batch->header_indices[count-1] + header_length;

			//printf("data_indices_size = %i: data_indices[%i] = %i\n", buffer_fq_read_batch->data_indices_size, count, buffer_fq_read_batch->data_indices[count]);

			// header_length
			accumulated_size += sequence_length + quality_length;

			  //printf("buffer_fq_read_batch->data_indices[%i]: %i\n", count-1, buffer_fq_read_batch->data_indices[count-1]);
			  //printf("buffer_fq_read_batch->data: %s\n", buffer_fq_read_batch->data);


		}else {
			CUDA_LOG_DEBUG("Read  has different length in sequence and quality");
		}

	}

	buffer_fq_read_batch->num_reads = count;
	//printf("accumulated_size: %d\n", accumulated_size);

	//fastq_batch_print(buffer_fq_read_batch, before_reader_fd);

	return buffer_fq_read_batch->num_reads;
}

//-----------------------------------------------------
// fastq_read (reads indicated in index_positions)
//-----------------------------------------------------
int fastq_read(fastq_read_t* buffer_reads, int *index_positions, fastq_file_t *fq_file) {
	const int max_length = 512;

	int count = 0;
	int index = 0;
	char header[max_length];
	char sequence[max_length];
	char plus[max_length];
	char quality[max_length];

	while (index_positions != NULL && fgets(header, max_length, fq_file->fd)!=NULL) {

		fgets(sequence, max_length, fq_file->fd);
		fgets(plus, max_length, fq_file->fd);
		fgets(quality, max_length, fq_file->fd);

		if (count == index_positions[index]) {
// 			buffer_reads[index].id = (char*)malloc(sizeof(char[strlen(trim(header))]));
// 			buffer_reads[index].sequence = (char*)malloc(sizeof(char[strlen(trim(sequence))]));
// 			buffer_reads[index].quality = (char*)malloc(sizeof(char[strlen(trim(quality))]));

			strcpy(buffer_reads[index].id, trim(header));
			strcpy(buffer_reads[index].sequence, trim(sequence));
			strcpy(buffer_reads[index].quality, trim(quality));

			index++;
		}

		count++;
	}

	return count;
}

//-----------------------------------------------------
// fastq_write
//-----------------------------------------------------
int fastq_write(fastq_read_t* buffer_reads, int num_writes, fastq_file_t *fq_file) {

	int count = 0;

	while (count<num_writes) {

		fprintf(fq_file->fd, "%s\n", buffer_reads->id);
		fprintf(fq_file->fd, "%s\n", buffer_reads->sequence);
		fprintf(fq_file->fd, "+\n");
		fprintf(fq_file->fd, "%s\n", buffer_reads->quality);

		buffer_reads++;
		count++;
	}

	return count;
}

//-----------------------------------------------------
// fastq_count
//-----------------------------------------------------
unsigned int fastq_count(fastq_file_t *fq_file) {
// 	if (fq_file->num_reads != -1) {
// 		return fq_file->num_reads;
// 	}

	return fq_file->num_reads;
}

//-----------------------------------------------------
// fastq_set_source_id
//-----------------------------------------------------

//void fastq_set_source_id(int source_id, fastq_file_t *fq_file) {
//    fq_file->source_id = source_id;
//}

//-----------------------------------------------------
// fastq_get_source_id
//-----------------------------------------------------

//int fastq_get_source_id(fastq_file_t *fq_file) {
//    return fq_file->source_id;
//}


//-----------------------------------------------------
// fastq_remove_Ns
//-----------------------------------------------------
void fastq_remove_Ns(fastq_read_t* buffer_reads, qc_read_t* qc_read, int max_N_per_read) {

	int count = 0;
	int index = 0;

	while (buffer_reads[count].id != NULL) {
		if (qc_read[count].counters[N] <= max_N_per_read) {
			buffer_reads[index] = buffer_reads[count];
			index++;
		}

		count++;
	}

	while (index <= count) {
// 		buffer_reads[index].id = NULL;
// 		buffer_reads[index].sequence = NULL;
// 		buffer_reads[index].quality = NULL;
		index++;
	}
}

//-----------------------------------------------------
// fastq_close
//-----------------------------------------------------
void fastq_close(fastq_file_t *fq_file) {
	fclose(fq_file->fd);
}

